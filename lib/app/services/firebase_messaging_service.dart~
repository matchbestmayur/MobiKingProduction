import 'package:firebase_messaging/firebase_messaging.dart';
// import 'package:flutter_local_notifications/flutter_local_notifications.dart'; // REMOVED
import 'package:get/get.dart';
import 'dart:convert'; // Import for jsonDecode

// Your specific imports for navigation
import 'package:mobiking/app/modules/bottombar/Bottom_bar.dart';
import 'package:mobiking/app/modules/home/home_screen.dart';
import 'package:mobiking/app/modules/orders/order_screen.dart';
import 'package:mobiking/app/themes/app_theme.dart'; // AppColors for snackbar

class FirebaseMessagingService {
  // Singleton pattern for easy global access
  static final FirebaseMessagingService _instance = FirebaseMessagingService._internal();

  factory FirebaseMessagingService() {
    return _instance;
  }

  FirebaseMessagingService._internal(); // Private constructor

  late FirebaseMessaging _firebaseMessaging;
  // late FlutterLocalNotificationsPlugin _flutterLocalNotificationsPlugin; // REMOVED

  // Initialize the service components
  Future<void> init() async {
    _firebaseMessaging = FirebaseMessaging.instance;
    // _flutterLocalNotificationsPlugin = FlutterLocalNotificationsPlugin(); // REMOVED

    // await _initializeLocalNotifications(); // REMOVED
    await _configureFirebaseMessaging();
  }

  // --- Local Notifications Setup (REMOVED THIS ENTIRE BLOCK) ---
  // Future<void> _initializeLocalNotifications() async {
  //   const AndroidInitializationSettings initializationSettingsAndroid =
  //   AndroidInitializationSettings('@mipmap/ic_launcher');
  //
  //   const DarwinInitializationSettings initializationSettingsIOS =
  //   DarwinInitializationSettings(
  //     requestAlertPermission: true,
  //     requestBadgePermission: true,
  //     requestSoundPermission: true,
  //   );
  //
  //   const InitializationSettings initializationSettings =
  //   InitializationSettings(
  //     android: initializationSettingsAndroid,
  //     iOS: initializationSettingsIOS,
  //   );
  //
  //   await _flutterLocalNotificationsPlugin.initialize(
  //     initializationSettings,
  //     onDidReceiveNotificationResponse: (NotificationResponse response) async {
  //       print('Notification tapped (foreground/background): ${response.payload}');
  //       _handleNotificationTap(response.payload);
  //     },
  //   );
  //
  //   const AndroidNotificationChannel channel = AndroidNotificationChannel(
  //     'high_importance_channel',
  //     'High Importance Notifications',
  //     description: 'This channel is used for important notifications.',
  //     importance: Importance.max,
  //   );
  //
  //   await _flutterLocalNotificationsPlugin
  //       .resolvePlatformSpecificImplementation<
  //       AndroidFlutterLocalNotificationsPlugin>()
  //       ?.createNotificationChannel(channel);
  // }


  // --- Firebase Messaging Configuration ---
  Future<void> _configureFirebaseMessaging() async {
    // Request notification permissions (primarily for iOS)
    NotificationSettings settings = await _firebaseMessaging.requestPermission(
      alert: true,
      announcement: false,
      badge: true,
      carPlay: false,
      criticalAlert: false,
      provisional: false,
      sound: true,
    );

    print('User granted permission: ${settings.authorizationStatus}');

    // Get the FCM token for the device
    String? token = await _firebaseMessaging.getToken();
    print('Initial FCM Token: $token');


    // Handle messages received while the app is in the foreground
    FirebaseMessaging.onMessage.listen((RemoteMessage message) {
      print('Got a message whilst in the foreground!');
      print('Message data: ${message.data}');

      // If the message contains a notification payload, it will NOT be displayed
      // automatically here without flutter_local_notifications.
      // You would only handle data messages or trigger UI updates here.
      if (message.notification != null) {
        print('Message also contained a notification: ${message.notification!.title}');
        // _showLocalNotification(message); // REMOVED: No longer showing local notification
        Get.snackbar(
          message.notification!.title ?? "New Notification",
          message.notification!.body ?? "You have a new message.",
          snackPosition: SnackPosition.TOP,
          backgroundColor: AppColors.darkPurple, // Using your defined colors
          colorText: AppColors.white,
          duration: const Duration(seconds: 5), // Show for a few seconds
        );
      }
      // You might want to handle data messages specifically here as well
      // if message.data contains information for in-app display.
    });

    // Handle messages when the app is opened from a terminated state by a notification tap
    FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
      print('App opened from terminated state by a notification: ${message.data}');
      // This will still work as it processes the data payload received from FCM
      _handleNotificationTap(jsonEncode(message.data));
    });

    // Background messages are handled by the top-level function _firebaseBackgroundMessagehandler in main.dart
  }

  // --- Display Local Notifications (REMOVED THIS ENTIRE BLOCK) ---
  // Future<void> _showLocalNotification(RemoteMessage message) async {
  //   RemoteNotification? notification = message.notification;
  //   AndroidNotification? android = message.notification?.android;
  //
  //   if (notification != null && android != null) {
  //     _flutterLocalNotificationsPlugin.show(
  //       notification.hashCode,
  //       notification.title,
  //       notification.body,
  //       NotificationDetails(
  //         android: AndroidNotificationDetails(
  //           'high_importance_channel',
  //           'High Importance Notifications',
  //           channelDescription: 'This channel is used for important notifications.',
  //           icon: android.smallIcon,
  //         ),
  //       ),
  //       payload: jsonEncode(message.data),
  //     );
  //   }
  // }


  // --- Handle Notification Tap Logic ---
  // This method centralizes navigation based on notification data
  // This still works because it processes FCM's data payload directly.
  void _handleNotificationTap(String? payload) {
    if (payload != null && payload.isNotEmpty) {
      try {
        Map<String, dynamic> data = jsonDecode(payload);
        String? screen = data['screen']; // Assuming your backend sends a 'screen' field
        String? orderId = data['orderId']; // Assuming your backend sends an 'orderId' field

        if (screen == 'orders') {
          if (orderId != null) {
            Get.to(() => OrderHistoryScreen(), arguments: {'orderId': orderId});
          } else {
            Get.to(() => OrderHistoryScreen());
          }
        } else if (screen == 'products') {
          Get.to(() => MainContainerScreen());
        } else {
          // Default navigation if no specific screen is matched
          Get.to(() => MainContainerScreen());
        }
      } catch (e) {
        print('Error parsing notification payload: $e');
        Get.snackbar("Notification Error", "Could not process notification data.",
            snackPosition: SnackPosition.BOTTOM,
            backgroundColor: AppColors.danger,
            colorText: AppColors.white);
      }
    }
  }

  // Optional: Method to get FCM token explicitly (used by FcmController)
  Future<String?> getFCMToken() async {
    return await _firebaseMessaging.getToken();
  }

  // --- Methods for permission status remain ---
  Future<AuthorizationStatus> getNotificationPermissionStatus() async {
    NotificationSettings settings = await _firebaseMessaging.getNotificationSettings();
    return settings.authorizationStatus;
  }

  Future<AuthorizationStatus> requestNotificationPermissions() async {
    NotificationSettings settings = await _firebaseMessaging.requestPermission(
      alert: true, announcement: false, badge: true, carPlay: false,
      criticalAlert: false, provisional: false, sound: true,
    );
    return settings.authorizationStatus;
  }
}
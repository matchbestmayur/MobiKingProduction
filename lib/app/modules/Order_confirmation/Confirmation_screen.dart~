import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';
import 'package:get/get.dart';
import 'package:intl/intl.dart';
import 'package:lottie/lottie.dart';
import 'package:mobiking/app/modules/Order_confirmation/widgets/AddressCard.dart';
import 'package:mobiking/app/modules/Order_confirmation/widgets/ShippingDetailsCard.dart';
import 'package:mobiking/app/modules/Order_confirmation/widgets/order_item_card.dart';
import 'package:mobiking/app/modules/Order_confirmation/widgets/order_summary_card.dart';
import '../../controllers/address_controller.dart';
import '../../controllers/order_controller.dart';
import '../../data/AddressModel.dart';
import '../../data/order_model.dart';
import '../../themes/app_theme.dart';
import '../bottombar/Bottom_bar.dart';

class OrderConfirmationScreen extends StatefulWidget {
  const OrderConfirmationScreen({Key? key}) : super(key: key);

  @override
  State<OrderConfirmationScreen> createState() => _OrderConfirmationScreenState();
}

class _OrderConfirmationScreenState extends State<OrderConfirmationScreen> with SingleTickerProviderStateMixin {
  late final OrderController orderController = Get.find<OrderController>();
  late final AddressController addressController = Get.find<AddressController>();

  late AnimationController _lottieController;
  final RxBool _showLottie = true.obs;
  final RxBool _isLottiePlayedOnce = false.obs;

  @override
  void initState() {
    super.initState();
    debugPrint('OrderConfirmationScreen initState called');

    _lottieController = AnimationController(vsync: this);

    _initializeDataAndLottie();

    once(orderController.isLoadingOrderHistory, (bool isLoading) {
      if (!isLoading && orderController.orderHistory.isNotEmpty && !_isLottiePlayedOnce.value) {
        debugPrint('Initial order history load completed, triggering Lottie play.');
        _playLottieAndShowDetails();
      } else if (!isLoading && orderController.orderHistory.isEmpty) {
        debugPrint('Order history loaded, but empty. Skipping Lottie and showing no orders.');
        SchedulerBinding.instance.addPostFrameCallback((_) {
          _showLottie.value = false;
          _isLottiePlayedOnce.value = true;
        });
      }
    }, condition: (isLoading) => !isLoading);
  }

  void _initializeDataAndLottie() {
    if (!_isLottiePlayedOnce.value && orderController.orderHistory.isEmpty && !orderController.isLoadingOrderHistory.value) {
      debugPrint('Triggering initial order history fetch and preparing Lottie.');
      _showLottie.value = true;
      orderController.fetchOrderHistory();
    } else if (orderController.orderHistory.isNotEmpty && !_isLottiePlayedOnce.value) {
      debugPrint('Order history already loaded on init. Playing Lottie for visual transition.');
      _playLottieAndShowDetails();
    } else {
      debugPrint('No Lottie conditions met on init, or Lottie already played. Setting _showLottie to false immediately.');
      SchedulerBinding.instance.addPostFrameCallback((_) {
        _showLottie.value = false;
      });
    }
  }

  void _playLottieAndShowDetails() {
    if (!_isLottiePlayedOnce.value && _lottieController.duration != null && _lottieController.duration! > Duration.zero) {
      debugPrint('Lottie play triggered. Duration: ${_lottieController.duration}');
      _lottieController.forward(from: 0.0).then((_) {
        debugPrint('Lottie animation completed. Hiding Lottie.');
        _showLottie.value = false;
        _isLottiePlayedOnce.value = true;
      }).onError((error, stackTrace) {
        debugPrint('Lottie animation error: $error');
        _showLottie.value = false;
        _isLottiePlayedOnce.value = true;
      });
    } else {
      debugPrint('Lottie not played: Already played (${_isLottiePlayedOnce.value}) or duration invalid.');
      SchedulerBinding.instance.addPostFrameCallback((_) {
        _showLottie.value = false;
      });
    }
  }

  @override
  void dispose() {
    _lottieController.dispose();
    _showLottie.close();
    _isLottiePlayedOnce.close();
    debugPrint('OrderConfirmationScreen dispose called');
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final TextTheme textTheme = Theme.of(context).textTheme;

    return Scaffold(
      backgroundColor: AppColors.neutralBackground,
      body: Obx(() {
        debugPrint('--- BUILD TRIGGERED ---');
        debugPrint('Current isLoadingOrderHistory: ${orderController.isLoadingOrderHistory.value}');
        debugPrint('Current _showLottie: ${_showLottie.value}');
        debugPrint('Current _isLottiePlayedOnce: ${_isLottiePlayedOnce.value}');

        bool showInitialLoadingState = _showLottie.value && (!_isLottiePlayedOnce.value || orderController.isLoadingOrderHistory.value);

        if (showInitialLoadingState) {
          debugPrint('Displaying Lottie Animation or Loading State.');
          return _buildLottieAnimation(context, textTheme);
        } else if (orderController.orderHistoryErrorMessage.isNotEmpty) {
          debugPrint('Displaying Error State.');
          return _buildError(context, textTheme);
        } else if (orderController.orderHistory.isEmpty) {
          debugPrint('Displaying No Orders Found State.');
          return _buildNoOrders(context, textTheme);
        } else {
          debugPrint('Displaying Order Details Screen.');
          return _buildOrderDetails(context, textTheme);
        }
      }),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
      floatingActionButton: Obx(() {
        if (_showLottie.value || orderController.isLoadingOrderHistory.value || orderController.orderHistory.isEmpty || orderController.orderHistoryErrorMessage.isNotEmpty) {
          return const SizedBox.shrink();
        }

        final OrderModel? mostRecentOrder = orderController.orderHistory.isNotEmpty
            ? orderController.orderHistory.first
            : null;

        bool shouldShowContinueShoppingButton = false;
        if (mostRecentOrder != null && mostRecentOrder.createdAt != null) {
          final DateTime now = DateTime.now();
          final Duration difference = now.difference(mostRecentOrder.createdAt!);

          if (difference.inDays < 7) {
            shouldShowContinueShoppingButton = true;
          }
        }

        if (!shouldShowContinueShoppingButton) {
          return const SizedBox.shrink();
        }

        return Padding(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12), // Adjusted vertical padding
          child: ElevatedButton.icon(
            onPressed: () {
              Get.offAll(() => MainContainerScreen());
              Get.snackbar(
                "Order Confirmed!",
                "Your order has been successfully placed. Explore more products!",
                backgroundColor: AppColors.success,
                colorText: AppColors.white,
                snackPosition: SnackPosition.BOTTOM,
                margin: const EdgeInsets.all(16), // Adjusted vertical margin
                borderRadius: 15,
                icon: const Icon(Icons.check_circle_outline, color: AppColors.white, size: 28),
                duration: const Duration(seconds: 4),
                animationDuration: const Duration(milliseconds: 500),
                mainButton: TextButton(
                  onPressed: () {
                    Get.back();
                  },
                  child: Text('View Order', style: textTheme.labelMedium?.copyWith(color: AppColors.white, fontWeight: FontWeight.w800)),
                ),
              );
            },
            icon: const Icon(Icons.shopping_bag_outlined, color: AppColors.white, size: 28),
            label: Text(
              "Continue Shopping",
              style: textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w800, color: AppColors.white),
            ),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.primaryPurple,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              minimumSize: const Size.fromHeight(56), // Adjusted height for better balance
              elevation: 10,
              shadowColor: AppColors.primaryPurple.withOpacity(0.4),
            ),
          ),
        );
      }),
    );
  }

  Widget _buildLottieAnimation(BuildContext context, TextTheme textTheme) {
    return Container(
      color: AppColors.neutralBackground,
      child: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Lottie.asset(
              'assets/animations/order.json',
              controller: _lottieController,
              onLoaded: (composition) {
                debugPrint('Lottie animation loaded. Duration: ${composition.duration}');
                if (_lottieController.duration != composition.duration) {
                  _lottieController.duration = composition.duration;
                  if (!_lottieController.isAnimating && _lottieController.status != AnimationStatus.completed && !_isLottiePlayedOnce.value) {
                    _lottieController.forward();
                  }
                }
              },
              repeat: false,
              width: MediaQuery.of(context).size.width * 0.9,
              height: MediaQuery.of(context).size.width * 0.9,
              fit: BoxFit.contain,
              errorBuilder: (context, error, stackTrace) {
                debugPrint('Lottie asset loading error: $error');
                SchedulerBinding.instance.addPostFrameCallback((_) {
                  _showLottie.value = false;
                  _isLottiePlayedOnce.value = true;
                });
                return Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(Icons.error_outline, size: 60, color: AppColors.danger),
                    const SizedBox(height: 12), // Adjusted vertical spacing
                    Text('Failed to load animation.', style: textTheme.bodyLarge?.copyWith(color: AppColors.danger)),
                    Text('Please check your internet connection.', style: textTheme.bodySmall?.copyWith(color: AppColors.textLight)),
                  ],
                );
              },
            ),
            const SizedBox(height: 12), // Adjusted vertical spacing
            Obx(() => Text(
              orderController.isLoadingOrderHistory.value ? 'Fetching your order details...' : 'Confirming your order...',
              textAlign: TextAlign.center,
              style: textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.w800,
                color: AppColors.textDark,
              ),
            )),
            if (orderController.isLoadingOrderHistory.value)
              const Padding(
                padding: EdgeInsets.only(top: 16), // Adjusted vertical spacing
                child: CircularProgressIndicator(color: AppColors.primaryPurple, strokeWidth: 4),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildError(BuildContext context, TextTheme textTheme) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.warning_amber_rounded, size: 80, color: AppColors.danger),
            const SizedBox(height: 12), // Adjusted vertical spacing
            Text(
              'Oops! Something went wrong.',
              textAlign: TextAlign.center,
              style: textTheme.headlineSmall?.copyWith(color: AppColors.textDark, fontWeight: FontWeight.w800),
            ),
            const SizedBox(height: 12), // Adjusted vertical spacing
            Text(
              orderController.orderHistoryErrorMessage.isNotEmpty
                  ? 'Error: ${orderController.orderHistoryErrorMessage.value}'
                  : 'We could not fetch your order details. Please try again.',
              textAlign: TextAlign.center,
              style: textTheme.bodyLarge?.copyWith(color: AppColors.textMedium),
            ),
            const SizedBox(height: 12), // Adjusted vertical spacing
            ElevatedButton.icon(
              onPressed: () {
                _showLottie.value = true;
                _isLottiePlayedOnce.value = false;
                _lottieController.reset();
                orderController.fetchOrderHistory();
              },
              icon: const Icon(Icons.refresh_rounded, color: AppColors.white, size: 12),
              label: Text('Retry', style: textTheme.titleMedium?.copyWith(color: AppColors.white, fontWeight: FontWeight.w800)),
              style: ElevatedButton.styleFrom(
                backgroundColor: AppColors.primaryPurple,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                elevation: 5,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildNoOrders(BuildContext context, TextTheme textTheme) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.shopping_basket_outlined, size: 90, color: AppColors.textMedium),
            const SizedBox(height: 12), // Adjusted vertical spacing
            Text(
              'No Recent Orders Found!',
              style: textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.w800, color: AppColors.textDark),
            ),
            const SizedBox(height: 12), // Adjusted vertical spacing
            Text(
              'It looks like you haven\'t placed any orders yet. Let\'s get you started!',
              textAlign: TextAlign.center,
              style: textTheme.bodyLarge?.copyWith(color: AppColors.textMedium),
            ),
            const SizedBox(height: 12), // Adjusted vertical spacing
            ElevatedButton.icon(
              onPressed: () {
                Get.offAll(() => MainContainerScreen());
              },
              icon: const Icon(Icons.shopping_cart_outlined, color: AppColors.white, size: 12),
              label: Text('Start Shopping', style: textTheme.titleMedium?.copyWith(color: AppColors.white, fontWeight: FontWeight.w800)),
              style: ElevatedButton.styleFrom(
                backgroundColor: AppColors.primaryPurple,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                elevation: 5,
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildOrderDetails(BuildContext context, TextTheme textTheme) {
    final OrderModel? order = orderController.orderHistory.isNotEmpty ? orderController.orderHistory.first : null;
    if (order == null) {
      debugPrint('Error: Order details requested but order is null, falling back to no orders.');
      return _buildNoOrders(context, textTheme);
    }

    final String recipientName = order.name?.isNotEmpty == true
        ? order.name!
        : (addressController.selectedAddress.value?.label ?? 'Recipient N/A');

    final String deliveryAddressText = order.address ?? 'Address not available for this order.';

    final orderTime = order.createdAt != null
        ? DateFormat('dd MMM, hh:mm a').format(order.createdAt!.toLocal())
        : 'N/A';

    return SingleChildScrollView(
      padding: const EdgeInsets.only(bottom: 80), // Adjusted bottom padding for FAB clearance
      child: Column(
          children: [
          Container(
          width: double.infinity,
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 32), // Adjusted vertical padding
          decoration: BoxDecoration(
            color: AppColors.success,
            borderRadius: const BorderRadius.only(bottomLeft: Radius.circular(30), bottomRight: Radius.circular(30)),
            boxShadow: [
              BoxShadow(
                color: AppColors.success.withOpacity(0.5),
                blurRadius: 20,
                offset: const Offset(0, 10),
              ),
            ],
          ),
          child: Column(
              children: [
              const Icon(Icons.check_circle_outline, size: 80, color: AppColors.white),
          const SizedBox(height: 16), // Adjusted vertical spacing
          Text(
            "Order Confirmed!",
            style: textTheme.headlineLarge?.copyWith(color: AppColors.white, fontWeight: FontWeight.w800, fontSize: 36),
          ),
          const SizedBox(height: 12), // Adjusted vertical spacing
          Text(
              "Your order ID #**${order.orderId ?? 'N/A'}** has been successfully placed.",
              textAlign: TextAlign.center,
              style : textTheme.titleLarge?.copyWith(color: AppColors.white.withOpacity(0.9), fontWeight: FontWeight.w500),
    ),
    const SizedBox(height: 12), // Adjusted vertical spacing
    Text(
    "A confirmation email has been sent to ${order.email ?? 'your registered email'}.",
    textAlign: TextAlign.center,
    style: textTheme.bodyLarge?.copyWith(color: AppColors.white.withOpacity(0.8)),
    ),
    const SizedBox(height: 12), // Adjusted vertical spacing
    Text(
    "Placed at: $orderTime",
    style: textTheme.bodyMedium?.copyWith(color: AppColors.white.withOpacity(0.7)),
    ),
    ],
    ),
    ),
    const SizedBox(height: 16), // Adjusted vertical spacing between header and content

    Padding(
    padding: const EdgeInsets.symmetric(horizontal: 12),
    child: Column(
    children: [
    _sectionTitle(context, textTheme, 'Delivery Address', Icons.location_on_outlined),
    AddressCard(phoneNumber: order.phoneNo, addressText: deliveryAddressText, recipientName: recipientName),
    ShippingDetailsCard(order: order),

    _sectionTitle(context, textTheme, 'Items in Your Order', Icons.shopping_bag_outlined),
    if (order.items.isNotEmpty)
    ...order.items.map((item) => Padding(
    padding: const EdgeInsets.only(bottom: 4), // Adjusted vertical spacing between items
    child: OrderItemCard(item: item, textTheme: textTheme),
    )).toList()
    else
    Card(
    color: AppColors.neutralBackground,
    elevation: 2,
    shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
    child: Padding(
    padding: const EdgeInsets.all(16.0),
    child: Text('No items listed for this order.',
    style: textTheme.bodyMedium?.copyWith(color: AppColors.textLight), textAlign: TextAlign.center),
    ),
    ),

    _sectionTitle(context, textTheme, 'Payment Summary', Icons.summarize_outlined),
    const SizedBox(height: 8), // Adjusted vertical spacing
    OrderSummaryCard(order: order, textTheme: textTheme),
    ],
    ),
    ),
    const SizedBox(height: 32), // Adjusted bottom padding for content
    ],
    ),
    );
  }

  Widget _sectionTitle(BuildContext context, TextTheme textTheme, String title, IconData icon) {
    return Align(
      alignment: Alignment.centerLeft,
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 12), // Adjusted vertical padding
        child: Row(
          children: [
            Icon(icon, color: AppColors.textDark, size: 28),
            const SizedBox(width: 12),
            Text(
              title,
              style: textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.w800, color: AppColors.textDark),
            ),
          ],
        ),
      ),
    );
  }
}